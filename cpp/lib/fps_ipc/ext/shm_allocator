


class Pool {
    private:
        class shmPool {
            private:
                struct Container {
                    containerMap* cont;
                };
                class Chunk {
                    public:
                        Chunk()
                        Chunk(Chunk&);
                        ~Chunk() {}
                        void* alloc(size_t size);
                        void free (void* p,size_t size);
                    private:
                        int shmId_;
                        int semId_;
                        int lock_()
                };
                int key_;
                char* path_;
                Chunk** chunks_;
                size_t segs_;
                size_t segSize_;
                Container* contPtr_;
                int contSemId_;
            public:
                shmPool();
                ~shmPool();
                size_t maxSize();
                void* alloc(size_t size);
                void free(void* p, size_t size);
                int shmPool::lockContainer()
                int unLockContainer()
                containerMap* getContainer()
                void shmPool::setContainer(containerMap* container)
        };

    private:
        static shmPool shm_;
        size_t elemSize_;
    public:
        Pool(size_t elemSize);
        ~Pool() {}
        size_t maxSize();
        void* alloc(size_t size);
        void free(void* p, size_t size);
        int lockContainer();
        int unLockContainer();
        containerMap* getContainer();
        void setContainer(containerMap* container);
};

inline bool operator==(const Pool& a,const Pool& b)
{
    return(a.compare(b));
}

template<class T>class SharedAllocator {
    private:
        Pool pool_;    // pool of elements of sizeof(T)
    public:
        typedef T value_type;
        typedef unsigned int  size_type;
        typedef ptrdiff_t difference_type;
        typedef T* pointer;
        typedef const T* const_pointer;
        typedef T& reference;
        typedef const T& const_reference;
        pointer address(reference r) const { return &r; }
        const_pointer address(const_reference r) const {return &r;}
        SharedAllocator() throw():pool_(sizeof(T)) {}
        template<class U> SharedAllocator
            (const SharedAllocator<U>& t) throw():
                        pool_(sizeof(T)) {}
        ~SharedAllocator() throw() {};
        // space for n Ts
        pointer allocate(size_t n, const void* hint=0)
        {
            return(static_cast<pointer> (pool_.alloc(n)));
        }
        // deallocate n Ts, don't destroy
        void deallocate(pointer p,size_type n)
        {
            pool_.free((void*)p,n);
            return;
        }
        // initialize *p by val
        void construct(pointer p, const T& val) { new(p) T(val); }
        // destroy *p but don't deallocate
        void destroy(pointer p) { p->~T(); }
        size_type max_size() const throw()
        {
            pool_.maxSize();
        }
        template<class U>    
        // in effect: typedef SharedAllocator<U> other
        struct rebind { typedef SharedAllocator<U> other; };
};

template<class T>bool operator==(const SharedAllocator<T>& a,
    const SharedAllocator<T>& b) throw()
{
        return(a.pool_ == b.pool_);
}
template<class T>bool operator!=(const SharedAllocator<T>& a,
    const SharedAllocator<T>& b) throw()
{
        return(!(a.pool_ == b.pool_));
}

struct keyComp {
    bool operator()(const char* key1,const char* key2)
    {
        return(strcmp(key1,key2)<0);
    }
};

class containerMap: public map<char*,void*,keyComp,SharedAllocator<char* > > {};
class containerFactory {
    public:
        containerFactory():pool_(sizeof(containerMap)){}
        ~containerFactory() {}
        template<class Container> Container* createContainer
            (char* key,Container* c=NULL);
        template<class Container> Container* getContainer
            (char* key,Container* c=NULL);
        template<class Container> int removeContainer
            (char* key,Container* c=NULL); 
    private:
        Pool pool_;
        int lock_();
        int unlock_();
};

